"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
exports.__esModule = true;
exports.getFiltersForMessage = exports.isEIP712Message = exports.signEIP712HashedMessage = exports.signEIP712Message = void 0;
var utils_1 = require("../../utils");
var loadConfig_1 = require("../../services/ledger/loadConfig");
var EIP712_utils_1 = require("./EIP712.utils");
/**
 * @ignore for the README
 *
 * Factory to create the recursive function that will pass on each
 * field level and APDUs to describe its structure implementation
 *
 * @param {Eth["sendStructImplem"]} sendStructImplem
 * @param {EIP712MessageTypes} types
 * @returns {void}
 */
var makeRecursiveFieldStructImplem = function (transport, types, filters) {
    var _a;
    var typesMap = {};
    for (var type in types) {
        typesMap[type] = (_a = types[type]) === null || _a === void 0 ? void 0 : _a.reduce(function (acc, curr) {
            var _a;
            return (__assign(__assign({}, acc), (_a = {}, _a[curr.name] = curr.type, _a)));
        }, {});
    }
    // This recursion will call itself to handle each level of each field
    // in order to send APDUs for each of them
    var recursiveFieldStructImplem = function (destructedType, data, path) {
        if (path === void 0) { path = ""; }
        return __awaiter(void 0, void 0, void 0, function () {
            var _a, typeDescription, arrSizes, _b, currSize, restSizes, isCustomType, data_1, data_1_1, entry, e_1_1, _c, _d, _e, fieldName, fieldValue, fieldType, e_2_1, filter;
            var e_1, _f, e_2, _g;
            var _h, _j;
            return __generator(this, function (_k) {
                switch (_k.label) {
                    case 0:
                        _a = __read(destructedType, 2), typeDescription = _a[0], arrSizes = _a[1];
                        _b = __read(arrSizes), currSize = _b[0], restSizes = _b.slice(1);
                        isCustomType = !EIP712_utils_1.EIP712_TYPE_PROPERTIES[((_h = typeDescription === null || typeDescription === void 0 ? void 0 : typeDescription.name) === null || _h === void 0 ? void 0 : _h.toUpperCase()) || ""];
                        if (!(Array.isArray(data) && typeof currSize !== "undefined")) return [3 /*break*/, 10];
                        return [4 /*yield*/, sendStructImplem(transport, {
                                structType: "array",
                                value: data.length
                            })];
                    case 1:
                        _k.sent();
                        _k.label = 2;
                    case 2:
                        _k.trys.push([2, 7, 8, 9]);
                        data_1 = __values(data), data_1_1 = data_1.next();
                        _k.label = 3;
                    case 3:
                        if (!!data_1_1.done) return [3 /*break*/, 6];
                        entry = data_1_1.value;
                        return [4 /*yield*/, recursiveFieldStructImplem([typeDescription, restSizes], entry, "".concat(path, ".[]"))];
                    case 4:
                        _k.sent();
                        _k.label = 5;
                    case 5:
                        data_1_1 = data_1.next();
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_1_1 = _k.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (data_1_1 && !data_1_1.done && (_f = data_1["return"])) _f.call(data_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 9: return [3 /*break*/, 23];
                    case 10:
                        if (!isCustomType) return [3 /*break*/, 19];
                        _k.label = 11;
                    case 11:
                        _k.trys.push([11, 16, 17, 18]);
                        _c = __values(Object.entries(data)), _d = _c.next();
                        _k.label = 12;
                    case 12:
                        if (!!_d.done) return [3 /*break*/, 15];
                        _e = __read(_d.value, 2), fieldName = _e[0], fieldValue = _e[1];
                        fieldType = (_j = typesMap[(typeDescription === null || typeDescription === void 0 ? void 0 : typeDescription.name) || ""]) === null || _j === void 0 ? void 0 : _j[fieldName];
                        if (!fieldType) return [3 /*break*/, 14];
                        return [4 /*yield*/, recursiveFieldStructImplem((0, EIP712_utils_1.destructTypeFromString)(fieldType), fieldValue, "".concat(path, ".").concat(fieldName))];
                    case 13:
                        _k.sent();
                        _k.label = 14;
                    case 14:
                        _d = _c.next();
                        return [3 /*break*/, 12];
                    case 15: return [3 /*break*/, 18];
                    case 16:
                        e_2_1 = _k.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 18];
                    case 17:
                        try {
                            if (_d && !_d.done && (_g = _c["return"])) _g.call(_c);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 18: return [3 /*break*/, 23];
                    case 19:
                        filter = filters === null || filters === void 0 ? void 0 : filters.fields.find(function (f) { return path === f.path; });
                        if (!filter) return [3 /*break*/, 21];
                        return [4 /*yield*/, sendFilteringInfo(transport, "showField", {
                                displayName: filter.label,
                                sig: filter.signature
                            })];
                    case 20:
                        _k.sent();
                        _k.label = 21;
                    case 21: return [4 /*yield*/, sendStructImplem(transport, {
                            structType: "field",
                            value: {
                                data: data,
                                type: (typeDescription === null || typeDescription === void 0 ? void 0 : typeDescription.name) || "",
                                sizeInBits: typeDescription === null || typeDescription === void 0 ? void 0 : typeDescription.bits
                            }
                        })];
                    case 22:
                        _k.sent();
                        _k.label = 23;
                    case 23: return [2 /*return*/];
                }
            });
        });
    };
    return recursiveFieldStructImplem;
};
/**
 * @ignore for the README
 *
 * This method is used to send the message definition with all its types.
 * This method should be used before the sendStructImplem one
 *
 * @param {String} structType
 * @param {String|Buffer} value
 * @returns {Promise<void>}
 */
var sendStructDef = function (transport, structDef) {
    var APDU_FIELDS;
    (function (APDU_FIELDS) {
        APDU_FIELDS[APDU_FIELDS["CLA"] = 224] = "CLA";
        APDU_FIELDS[APDU_FIELDS["INS"] = 26] = "INS";
        APDU_FIELDS[APDU_FIELDS["P1_complete"] = 0] = "P1_complete";
        APDU_FIELDS[APDU_FIELDS["P1_partial"] = 1] = "P1_partial";
        APDU_FIELDS[APDU_FIELDS["P2_name"] = 0] = "P2_name";
        APDU_FIELDS[APDU_FIELDS["P2_field"] = 255] = "P2_field";
    })(APDU_FIELDS || (APDU_FIELDS = {}));
    var structType = structDef.structType, value = structDef.value;
    var data = structType === "name" && typeof value === "string"
        ? Buffer.from(value, "utf-8")
        : value;
    return transport.send(APDU_FIELDS.CLA, APDU_FIELDS.INS, APDU_FIELDS.P1_complete, structType === "name" ? APDU_FIELDS.P2_name : APDU_FIELDS.P2_field, data);
};
/**
 * @ignore for the README
 *
 * This method provides a trusted new display name to use for the upcoming field.
 * This method should be used after the sendStructDef one.
 *
 * If the method describes an empty name (length of 0), the upcoming field will be taken
 * into account but won’t be shown on the device.
 *
 * The signature is computed on :
 * json key length || json key || display name length || display name
 *
 * signed by the following secp256k1 public key:
 * 0482bbf2f34f367b2e5bc21847b6566f21f0976b22d3388a9a5e446ac62d25cf725b62a2555b2dd464a4da0ab2f4d506820543af1d242470b1b1a969a27578f353
 *
 * @param {String} structType "root" | "array" | "field"
 * @param {string | number | StructFieldData} value
 * @returns {Promise<Buffer | void>}
 */
var sendStructImplem = function (transport, structImplem) { return __awaiter(void 0, void 0, void 0, function () {
    var APDU_FIELDS, structType, value, rawData, type, sizeInBits, encodedData, dataLengthPer16Bits, dataLengthModulo16Bits, data_2, bufferSlices, bufferSlices_1, bufferSlices_1_1, bufferSlice, e_3_1;
    var e_3, _a;
    var _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                (function (APDU_FIELDS) {
                    APDU_FIELDS[APDU_FIELDS["CLA"] = 224] = "CLA";
                    APDU_FIELDS[APDU_FIELDS["INS"] = 28] = "INS";
                    APDU_FIELDS[APDU_FIELDS["P1_complete"] = 0] = "P1_complete";
                    APDU_FIELDS[APDU_FIELDS["P1_partial"] = 1] = "P1_partial";
                    APDU_FIELDS[APDU_FIELDS["P2_root"] = 0] = "P2_root";
                    APDU_FIELDS[APDU_FIELDS["P2_array"] = 15] = "P2_array";
                    APDU_FIELDS[APDU_FIELDS["P2_field"] = 255] = "P2_field";
                })(APDU_FIELDS || (APDU_FIELDS = {}));
                structType = structImplem.structType, value = structImplem.value;
                if (structType === "root") {
                    return [2 /*return*/, transport.send(APDU_FIELDS.CLA, APDU_FIELDS.INS, APDU_FIELDS.P1_complete, APDU_FIELDS.P2_root, Buffer.from(value, "utf-8"))];
                }
                if (structType === "array") {
                    return [2 /*return*/, transport.send(APDU_FIELDS.CLA, APDU_FIELDS.INS, APDU_FIELDS.P1_complete, APDU_FIELDS.P2_array, Buffer.from((0, utils_1.intAsHexBytes)(value, 1), "hex"))];
                }
                if (!(structType === "field")) return [3 /*break*/, 8];
                rawData = value.data, type = value.type, sizeInBits = value.sizeInBits;
                encodedData = (_b = EIP712_utils_1.EIP712_TYPE_ENCODERS[type.toUpperCase()]) === null || _b === void 0 ? void 0 : _b.call(EIP712_utils_1.EIP712_TYPE_ENCODERS, rawData, sizeInBits);
                if (!encodedData) return [3 /*break*/, 8];
                dataLengthPer16Bits = Math.floor(encodedData.length / 256);
                dataLengthModulo16Bits = encodedData.length % 256;
                data_2 = Buffer.concat([
                    Buffer.from((0, utils_1.intAsHexBytes)(dataLengthPer16Bits, 1), "hex"),
                    Buffer.from((0, utils_1.intAsHexBytes)(dataLengthModulo16Bits, 1), "hex"),
                    encodedData,
                ]);
                bufferSlices = new Array(Math.ceil(data_2.length / 256))
                    .fill(null)
                    .map(function (_, i) { return data_2.slice(i * 255, (i + 1) * 255); });
                _c.label = 1;
            case 1:
                _c.trys.push([1, 6, 7, 8]);
                bufferSlices_1 = __values(bufferSlices), bufferSlices_1_1 = bufferSlices_1.next();
                _c.label = 2;
            case 2:
                if (!!bufferSlices_1_1.done) return [3 /*break*/, 5];
                bufferSlice = bufferSlices_1_1.value;
                return [4 /*yield*/, transport.send(APDU_FIELDS.CLA, APDU_FIELDS.INS, bufferSlice !== bufferSlices[bufferSlices.length - 1]
                        ? APDU_FIELDS.P1_partial
                        : APDU_FIELDS.P1_complete, APDU_FIELDS.P2_field, bufferSlice)];
            case 3:
                _c.sent();
                _c.label = 4;
            case 4:
                bufferSlices_1_1 = bufferSlices_1.next();
                return [3 /*break*/, 2];
            case 5: return [3 /*break*/, 8];
            case 6:
                e_3_1 = _c.sent();
                e_3 = { error: e_3_1 };
                return [3 /*break*/, 8];
            case 7:
                try {
                    if (bufferSlices_1_1 && !bufferSlices_1_1.done && (_a = bufferSlices_1["return"])) _a.call(bufferSlices_1);
                }
                finally { if (e_3) throw e_3.error; }
                return [7 /*endfinally*/];
            case 8: return [2 /*return*/, Promise.resolve()];
        }
    });
}); };
function sendFilteringInfo(transport, type, data) {
    return __awaiter(this, void 0, void 0, function () {
        var APDU_FIELDS, _a, displayName, filtersCount, sig, displayNameLengthBuffer, displayNameBuffer, filtersCountBuffer, sigLengthBuffer, sigBuffer, callData, _b, displayName, sig, displayNameLengthBuffer, displayNameBuffer, sigLengthBuffer, sigBuffer, callData;
        return __generator(this, function (_c) {
            (function (APDU_FIELDS) {
                APDU_FIELDS[APDU_FIELDS["CLA"] = 224] = "CLA";
                APDU_FIELDS[APDU_FIELDS["INS"] = 30] = "INS";
                APDU_FIELDS[APDU_FIELDS["P1"] = 0] = "P1";
                APDU_FIELDS[APDU_FIELDS["P2_activate"] = 0] = "P2_activate";
                APDU_FIELDS[APDU_FIELDS["P2_contract_name"] = 15] = "P2_contract_name";
                APDU_FIELDS[APDU_FIELDS["P2_show_field"] = 255] = "P2_show_field";
            })(APDU_FIELDS || (APDU_FIELDS = {}));
            switch (type) {
                case "activate":
                    return [2 /*return*/, transport.send(APDU_FIELDS.CLA, APDU_FIELDS.INS, APDU_FIELDS.P1, APDU_FIELDS.P2_activate)];
                case "contractName": {
                    _a = data, displayName = _a.displayName, filtersCount = _a.filtersCount, sig = _a.sig;
                    displayNameLengthBuffer = Buffer.from((0, utils_1.intAsHexBytes)(displayName.length, 1), "hex");
                    displayNameBuffer = Buffer.from(displayName);
                    filtersCountBuffer = Buffer.from((0, utils_1.intAsHexBytes)(filtersCount, 1), "hex");
                    sigLengthBuffer = Buffer.from((0, utils_1.intAsHexBytes)(sig.length / 2, 1), "hex");
                    sigBuffer = Buffer.from(sig, "hex");
                    callData = Buffer.concat([
                        displayNameLengthBuffer,
                        displayNameBuffer,
                        filtersCountBuffer,
                        sigLengthBuffer,
                        sigBuffer,
                    ]);
                    return [2 /*return*/, transport.send(APDU_FIELDS.CLA, APDU_FIELDS.INS, APDU_FIELDS.P1, APDU_FIELDS.P2_contract_name, callData)];
                }
                case "showField": {
                    _b = data, displayName = _b.displayName, sig = _b.sig;
                    displayNameLengthBuffer = Buffer.from((0, utils_1.intAsHexBytes)(displayName.length, 1), "hex");
                    displayNameBuffer = Buffer.from(displayName);
                    sigLengthBuffer = Buffer.from((0, utils_1.intAsHexBytes)(sig.length / 2, 1), "hex");
                    sigBuffer = Buffer.from(sig, "hex");
                    callData = Buffer.concat([
                        displayNameLengthBuffer,
                        displayNameBuffer,
                        sigLengthBuffer,
                        sigBuffer,
                    ]);
                    return [2 /*return*/, transport.send(APDU_FIELDS.CLA, APDU_FIELDS.INS, APDU_FIELDS.P1, APDU_FIELDS.P2_show_field, callData)];
                }
            }
            return [2 /*return*/];
        });
    });
}
/**
 * @ignore for the README
 *
 * Sign an EIP-721 formatted message following the specification here:
 * https://github.com/LedgerHQ/app-ethereum/blob/develop/doc/ethapp.asc#sign-eth-eip-712
 * @example
  eth.signEIP721Message("44'/60'/0'/0/0", {
    domain: {
      chainId: 69,
      name: "Da Domain",
      verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
      version: "1"
    },
    types: {
      "EIP712Domain": [
            { name: "name", type: "string" },
            { name: "version", type: "string" },
            { name: "chainId", type: "uint256" },
            { name: "verifyingContract", type: "address" }
        ],
      "Test": [
        { name: "contents", type: "string" }
      ]
    },
    primaryType: "Test",
    message: {contents: "Hello, Bob!"},
  })
 *
 * @param {String} path derivationPath
 * @param {Object} jsonMessage message to sign
 * @param {Boolean} fullImplem use the legacy implementation
 * @returns {Promise}
 */
var signEIP712Message = function (transport, path, jsonMessage, fullImplem, loadConfig) {
    if (fullImplem === void 0) { fullImplem = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var APDU_FIELDS, primaryType, unsortedTypes, domain, message, cryptoassetsBaseURL, types, filters, typeEntries, typeEntries_1, typeEntries_1_1, _a, typeName, entries, entries_1, entries_1_1, _b, name_1, type, typeEntryBuffer, e_4_1, e_5_1, recursiveFieldStructImplem, domainName, domainTypeFields, domainTypeFields_1, domainTypeFields_1_1, _c, name_2, type, domainFieldValue, e_6_1, contractName, fields, contractNameInfos, primaryTypeFields, primaryTypeFields_1, primaryTypeFields_1_1, _d, name_3, type, primaryTypeValue, e_7_1, paths, signatureBuffer;
        var e_5, _e, e_4, _f, e_6, _g, e_7, _h;
        return __generator(this, function (_j) {
            switch (_j.label) {
                case 0:
                    (function (APDU_FIELDS) {
                        APDU_FIELDS[APDU_FIELDS["CLA"] = 224] = "CLA";
                        APDU_FIELDS[APDU_FIELDS["INS"] = 12] = "INS";
                        APDU_FIELDS[APDU_FIELDS["P1"] = 0] = "P1";
                        APDU_FIELDS[APDU_FIELDS["P2_v0"] = 0] = "P2_v0";
                        APDU_FIELDS[APDU_FIELDS["P2_full"] = 1] = "P2_full";
                    })(APDU_FIELDS || (APDU_FIELDS = {}));
                    primaryType = jsonMessage.primaryType, unsortedTypes = jsonMessage.types, domain = jsonMessage.domain, message = jsonMessage.message;
                    cryptoassetsBaseURL = (0, loadConfig_1.getLoadConfig)(loadConfig).cryptoassetsBaseURL;
                    types = (0, EIP712_utils_1.sortObjectAlphabetically)(unsortedTypes);
                    return [4 /*yield*/, (0, EIP712_utils_1.getFiltersForMessage)(jsonMessage, cryptoassetsBaseURL)];
                case 1:
                    filters = _j.sent();
                    typeEntries = Object.entries(types);
                    _j.label = 2;
                case 2:
                    _j.trys.push([2, 14, 15, 16]);
                    typeEntries_1 = __values(typeEntries), typeEntries_1_1 = typeEntries_1.next();
                    _j.label = 3;
                case 3:
                    if (!!typeEntries_1_1.done) return [3 /*break*/, 13];
                    _a = __read(typeEntries_1_1.value, 2), typeName = _a[0], entries = _a[1];
                    return [4 /*yield*/, sendStructDef(transport, {
                            structType: "name",
                            value: typeName
                        })];
                case 4:
                    _j.sent();
                    _j.label = 5;
                case 5:
                    _j.trys.push([5, 10, 11, 12]);
                    entries_1 = (e_4 = void 0, __values(entries)), entries_1_1 = entries_1.next();
                    _j.label = 6;
                case 6:
                    if (!!entries_1_1.done) return [3 /*break*/, 9];
                    _b = entries_1_1.value, name_1 = _b.name, type = _b.type;
                    typeEntryBuffer = (0, EIP712_utils_1.makeTypeEntryStructBuffer)({ name: name_1, type: type });
                    return [4 /*yield*/, sendStructDef(transport, {
                            structType: "field",
                            value: typeEntryBuffer
                        })];
                case 7:
                    _j.sent();
                    _j.label = 8;
                case 8:
                    entries_1_1 = entries_1.next();
                    return [3 /*break*/, 6];
                case 9: return [3 /*break*/, 12];
                case 10:
                    e_4_1 = _j.sent();
                    e_4 = { error: e_4_1 };
                    return [3 /*break*/, 12];
                case 11:
                    try {
                        if (entries_1_1 && !entries_1_1.done && (_f = entries_1["return"])) _f.call(entries_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                    return [7 /*endfinally*/];
                case 12:
                    typeEntries_1_1 = typeEntries_1.next();
                    return [3 /*break*/, 3];
                case 13: return [3 /*break*/, 16];
                case 14:
                    e_5_1 = _j.sent();
                    e_5 = { error: e_5_1 };
                    return [3 /*break*/, 16];
                case 15:
                    try {
                        if (typeEntries_1_1 && !typeEntries_1_1.done && (_e = typeEntries_1["return"])) _e.call(typeEntries_1);
                    }
                    finally { if (e_5) throw e_5.error; }
                    return [7 /*endfinally*/];
                case 16:
                    if (!filters) return [3 /*break*/, 18];
                    return [4 /*yield*/, sendFilteringInfo(transport, "activate")];
                case 17:
                    _j.sent();
                    _j.label = 18;
                case 18:
                    recursiveFieldStructImplem = makeRecursiveFieldStructImplem(transport, types, filters);
                    domainName = "EIP712Domain";
                    return [4 /*yield*/, sendStructImplem(transport, {
                            structType: "root",
                            value: domainName
                        })];
                case 19:
                    _j.sent();
                    domainTypeFields = types[domainName];
                    _j.label = 20;
                case 20:
                    _j.trys.push([20, 25, 26, 27]);
                    domainTypeFields_1 = __values(domainTypeFields), domainTypeFields_1_1 = domainTypeFields_1.next();
                    _j.label = 21;
                case 21:
                    if (!!domainTypeFields_1_1.done) return [3 /*break*/, 24];
                    _c = domainTypeFields_1_1.value, name_2 = _c.name, type = _c.type;
                    domainFieldValue = domain[name_2];
                    return [4 /*yield*/, recursiveFieldStructImplem((0, EIP712_utils_1.destructTypeFromString)(type), domainFieldValue)];
                case 22:
                    _j.sent();
                    _j.label = 23;
                case 23:
                    domainTypeFields_1_1 = domainTypeFields_1.next();
                    return [3 /*break*/, 21];
                case 24: return [3 /*break*/, 27];
                case 25:
                    e_6_1 = _j.sent();
                    e_6 = { error: e_6_1 };
                    return [3 /*break*/, 27];
                case 26:
                    try {
                        if (domainTypeFields_1_1 && !domainTypeFields_1_1.done && (_g = domainTypeFields_1["return"])) _g.call(domainTypeFields_1);
                    }
                    finally { if (e_6) throw e_6.error; }
                    return [7 /*endfinally*/];
                case 27:
                    if (!filters) return [3 /*break*/, 29];
                    contractName = filters.contractName, fields = filters.fields;
                    contractNameInfos = {
                        displayName: contractName.label,
                        filtersCount: fields.length,
                        sig: contractName.signature
                    };
                    return [4 /*yield*/, sendFilteringInfo(transport, "contractName", contractNameInfos)];
                case 28:
                    _j.sent();
                    _j.label = 29;
                case 29: 
                // Looping on all primaryType type's entries and fields to send
                // structures' implementations
                return [4 /*yield*/, sendStructImplem(transport, {
                        structType: "root",
                        value: primaryType
                    })];
                case 30:
                    // Looping on all primaryType type's entries and fields to send
                    // structures' implementations
                    _j.sent();
                    primaryTypeFields = types[primaryType];
                    _j.label = 31;
                case 31:
                    _j.trys.push([31, 36, 37, 38]);
                    primaryTypeFields_1 = __values(primaryTypeFields), primaryTypeFields_1_1 = primaryTypeFields_1.next();
                    _j.label = 32;
                case 32:
                    if (!!primaryTypeFields_1_1.done) return [3 /*break*/, 35];
                    _d = primaryTypeFields_1_1.value, name_3 = _d.name, type = _d.type;
                    primaryTypeValue = message[name_3];
                    return [4 /*yield*/, recursiveFieldStructImplem((0, EIP712_utils_1.destructTypeFromString)(type), primaryTypeValue, name_3)];
                case 33:
                    _j.sent();
                    _j.label = 34;
                case 34:
                    primaryTypeFields_1_1 = primaryTypeFields_1.next();
                    return [3 /*break*/, 32];
                case 35: return [3 /*break*/, 38];
                case 36:
                    e_7_1 = _j.sent();
                    e_7 = { error: e_7_1 };
                    return [3 /*break*/, 38];
                case 37:
                    try {
                        if (primaryTypeFields_1_1 && !primaryTypeFields_1_1.done && (_h = primaryTypeFields_1["return"])) _h.call(primaryTypeFields_1);
                    }
                    finally { if (e_7) throw e_7.error; }
                    return [7 /*endfinally*/];
                case 38:
                    paths = (0, utils_1.splitPath)(path);
                    signatureBuffer = Buffer.alloc(1 + paths.length * 4);
                    signatureBuffer[0] = paths.length;
                    paths.forEach(function (element, index) {
                        signatureBuffer.writeUInt32BE(element, 1 + 4 * index);
                    });
                    return [2 /*return*/, transport
                            .send(APDU_FIELDS.CLA, APDU_FIELDS.INS, APDU_FIELDS.P1, fullImplem ? APDU_FIELDS.P2_v0 : APDU_FIELDS.P2_full, signatureBuffer)
                            .then(function (response) {
                            var v = response[0];
                            var r = response.slice(1, 1 + 32).toString("hex");
                            var s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
                            return {
                                v: v,
                                r: r,
                                s: s
                            };
                        })];
            }
        });
    });
};
exports.signEIP712Message = signEIP712Message;
/**
 * @ignore for the README
 * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)
 * @example
 eth.signEIP712HashedMessage("44'/60'/0'/0/0", Buffer.from("0101010101010101010101010101010101010101010101010101010101010101").toString("hex"), Buffer.from("0202020202020202020202020202020202020202020202020202020202020202").toString("hex")).then(result => {
 var v = result['v'] - 27;
 v = v.toString(16);
 if (v.length < 2) {
   v = "0" + v;
 }
 console.log("Signature 0x" + result['r'] + result['s'] + v);
 })
 */
var signEIP712HashedMessage = function (transport, path, domainSeparatorHex, hashStructMessageHex) {
    var domainSeparator = (0, utils_1.hexBuffer)(domainSeparatorHex);
    var hashStruct = (0, utils_1.hexBuffer)(hashStructMessageHex);
    var paths = (0, utils_1.splitPath)(path);
    var buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);
    var offset = 0;
    buffer[0] = paths.length;
    paths.forEach(function (element, index) {
        buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    offset = 1 + 4 * paths.length;
    domainSeparator.copy(buffer, offset);
    offset += 32;
    hashStruct.copy(buffer, offset);
    return transport.send(0xe0, 0x0c, 0x00, 0x00, buffer).then(function (response) {
        var v = response[0];
        var r = response.slice(1, 1 + 32).toString("hex");
        var s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
        return {
            v: v,
            r: r,
            s: s
        };
    });
};
exports.signEIP712HashedMessage = signEIP712HashedMessage;
var EIP712_utils_2 = require("./EIP712.utils");
__createBinding(exports, EIP712_utils_2, "isEIP712Message");
__createBinding(exports, EIP712_utils_2, "getFiltersForMessage");
//# sourceMappingURL=index.js.map