"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
exports.__esModule = true;
// This implements the resolution of a Transaction using Ledger's own API
var logs_1 = require("@ledgerhq/logs");
var abi_1 = require("@ethersproject/abi");
var contracts_1 = require("./contracts");
var erc20_1 = require("./erc20");
var nfts_1 = require("./nfts");
var utils_1 = require("../../utils");
/**
 * @ignore for external documentation
 *
 * Providing additionnal data for some transactions (Token or NFT related) can enable clear signing
 * of initially impossible to decode data.
 * This method will add necessary APDUs to the resolution paramter in order to provide this data to the nano app
 */
var getAdditionalDataForContract = function (contractAddress, chainIdTruncated, loadConfig, shouldResolve) { return __awaiter(void 0, void 0, void 0, function () {
    var resolution, nftInfo, erc20SignaturesBlob, erc20Info;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                resolution = {
                    nfts: [],
                    erc20Tokens: []
                };
                if (!shouldResolve.nft) return [3 /*break*/, 2];
                return [4 /*yield*/, (0, nfts_1.getNFTInfo)(contractAddress, chainIdTruncated, loadConfig)];
            case 1:
                nftInfo = _a.sent();
                if (nftInfo) {
                    (0, logs_1.log)("ethereum", "loaded nft info for " +
                        nftInfo.contractAddress +
                        " (" +
                        nftInfo.collectionName +
                        ")");
                    resolution.nfts.push(nftInfo.data);
                }
                else {
                    (0, logs_1.log)("ethereum", "couldn't load nft info for " + contractAddress);
                }
                _a.label = 2;
            case 2:
                if (!shouldResolve.token) return [3 /*break*/, 4];
                return [4 /*yield*/, (0, erc20_1.findERC20SignaturesInfo)(loadConfig, chainIdTruncated)];
            case 3:
                erc20SignaturesBlob = _a.sent();
                erc20Info = (0, erc20_1.byContractAddressAndChainId)(contractAddress, chainIdTruncated, erc20SignaturesBlob);
                if (erc20Info) {
                    (0, logs_1.log)("ethereum", "loaded erc20token info for " +
                        erc20Info.contractAddress +
                        " (" +
                        erc20Info.ticker +
                        ")");
                    resolution.erc20Tokens.push(erc20Info.data.toString("hex"));
                }
                else {
                    (0, logs_1.log)("ethereum", "couldn't load erc20token info for " + contractAddress);
                }
                _a.label = 4;
            case 4: return [2 /*return*/, resolution];
        }
    });
}); };
/**
 * @ignore for external documentation
 *
 * Depending on the transaction, it might be necessary to load internal plugins in the nano app
 * in order to clear sign it.
 * This method will add necessary APDUs to the resolution parameter in order to load those internal plugins
 */
var loadNanoAppPlugins = function (contractAddress, selector, decodedTx, chainIdTruncated, loadConfig, shouldResolve) { return __awaiter(void 0, void 0, void 0, function () {
    var resolution, nftPluginPayload, contractMethodInfos, plugin, payload, signature, erc20OfInterest, abi, contract, args, erc20OfInterest_1, erc20OfInterest_1_1, path, erc20ContractAddress, externalPluginResolution, e_1_1;
    var e_1, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                resolution = {
                    externalPlugin: [],
                    plugin: [],
                    nfts: [],
                    erc20Tokens: []
                };
                if (!shouldResolve.nft) return [3 /*break*/, 2];
                return [4 /*yield*/, (0, nfts_1.loadNftPlugin)(contractAddress, selector, chainIdTruncated, loadConfig)];
            case 1:
                nftPluginPayload = _b.sent();
                if (nftPluginPayload) {
                    resolution.plugin.push(nftPluginPayload);
                }
                else {
                    (0, logs_1.log)("ethereum", "no NFT plugin payload for selector " +
                        selector +
                        " and address " +
                        contractAddress);
                }
                _b.label = 2;
            case 2:
                if (!shouldResolve.externalPlugins) return [3 /*break*/, 13];
                return [4 /*yield*/, (0, contracts_1.loadInfosForContractMethod)(contractAddress, selector, chainIdTruncated, loadConfig)];
            case 3:
                contractMethodInfos = _b.sent();
                if (!contractMethodInfos) return [3 /*break*/, 12];
                plugin = contractMethodInfos.plugin, payload = contractMethodInfos.payload, signature = contractMethodInfos.signature, erc20OfInterest = contractMethodInfos.erc20OfInterest, abi = contractMethodInfos.abi;
                if (plugin) {
                    (0, logs_1.log)("ethereum", "found plugin for " + selector);
                    resolution.externalPlugin.push({ payload: payload, signature: signature });
                }
                if (!(erc20OfInterest && erc20OfInterest.length && abi)) return [3 /*break*/, 11];
                contract = new abi_1.Interface(abi);
                args = contract.parseTransaction(decodedTx).args;
                _b.label = 4;
            case 4:
                _b.trys.push([4, 9, 10, 11]);
                erc20OfInterest_1 = __values(erc20OfInterest), erc20OfInterest_1_1 = erc20OfInterest_1.next();
                _b.label = 5;
            case 5:
                if (!!erc20OfInterest_1_1.done) return [3 /*break*/, 8];
                path = erc20OfInterest_1_1.value;
                erc20ContractAddress = path.split(".").reduce(function (value, seg) {
                    if (seg === "-1" && Array.isArray(value)) {
                        return value[value.length - 1];
                    }
                    return value[seg];
                }, args);
                return [4 /*yield*/, getAdditionalDataForContract(erc20ContractAddress, chainIdTruncated, loadConfig, {
                        nft: false,
                        externalPlugins: false,
                        token: true
                    })];
            case 6:
                externalPluginResolution = _b.sent();
                resolution = (0, utils_1.mergeResolutions)(resolution, externalPluginResolution);
                _b.label = 7;
            case 7:
                erc20OfInterest_1_1 = erc20OfInterest_1.next();
                return [3 /*break*/, 5];
            case 8: return [3 /*break*/, 11];
            case 9:
                e_1_1 = _b.sent();
                e_1 = { error: e_1_1 };
                return [3 /*break*/, 11];
            case 10:
                try {
                    if (erc20OfInterest_1_1 && !erc20OfInterest_1_1.done && (_a = erc20OfInterest_1["return"])) _a.call(erc20OfInterest_1);
                }
                finally { if (e_1) throw e_1.error; }
                return [7 /*endfinally*/];
            case 11: return [3 /*break*/, 13];
            case 12:
                (0, logs_1.log)("ethereum", "no infos for selector " + selector);
                _b.label = 13;
            case 13: return [2 /*return*/, resolution];
        }
    });
}); };
var ledgerService = {
    resolveTransaction: function (rawTxHex, loadConfig, resolutionConfig) { return __awaiter(void 0, void 0, void 0, function () {
        var rawTx, _a, decodedTx, chainIdTruncated, contractAddress, selector, pluginsResolution, contractResolution, shouldResolve;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    rawTx = Buffer.from(rawTxHex, "hex");
                    _a = (0, utils_1.decodeTxInfo)(rawTx), decodedTx = _a.decodedTx, chainIdTruncated = _a.chainIdTruncated;
                    contractAddress = decodedTx.to;
                    selector = decodedTx.data.length >= 10 && decodedTx.data.substring(0, 10);
                    pluginsResolution = {};
                    contractResolution = {};
                    if (!selector) return [3 /*break*/, 3];
                    shouldResolve = {
                        token: resolutionConfig.erc20 && utils_1.tokenSelectors.includes(selector),
                        nft: resolutionConfig.nft && utils_1.nftSelectors.includes(selector),
                        externalPlugins: resolutionConfig.externalPlugins
                    };
                    return [4 /*yield*/, loadNanoAppPlugins(contractAddress, selector, decodedTx, chainIdTruncated, loadConfig, shouldResolve)];
                case 1:
                    pluginsResolution = _b.sent();
                    return [4 /*yield*/, getAdditionalDataForContract(contractAddress, chainIdTruncated, loadConfig, shouldResolve)];
                case 2:
                    contractResolution = _b.sent();
                    _b.label = 3;
                case 3: return [2 /*return*/, (0, utils_1.mergeResolutions)(pluginsResolution, contractResolution)];
            }
        });
    }); }
};
exports["default"] = ledgerService;
//# sourceMappingURL=index.js.map