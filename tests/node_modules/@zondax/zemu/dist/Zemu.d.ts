/// <reference types="node" />
/** ******************************************************************************
 *  (c) 2018 - 2023 Zondax AG
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ******************************************************************************* */
import { type AxiosResponse } from "axios";
import { type PNGWithMetadata } from "pngjs";
import type Transport from "@ledgerhq/hw-transport";
import { type IButton, type IDeviceWindow, type IEvent, type INavElement, type ISnapshot, type IStartOptions, type TModel } from "./types";
export default class Zemu {
    private startOptions;
    private readonly host;
    private transport;
    private readonly transportProtocol;
    private transportPort;
    protected speculosApiPort: number;
    private readonly desiredTransportPort?;
    private readonly desiredSpeculosApiPort?;
    private readonly emuContainer;
    private readonly containerName;
    private readonly elfPath;
    private readonly libElfs;
    private grpcManager?;
    private mainMenuSnapshot;
    constructor(elfPath: string, libElfs?: Record<string, string>, host?: string, desiredTransportPort?: number, desiredSpeculosApiPort?: number, emuImage?: string);
    static LoadPng2RGB(filename: string): PNGWithMetadata;
    static sleep(timeInMs?: number): Promise<void>;
    static stopAllEmuContainers(): void;
    static checkAndPullImage(): void;
    static checkElf(model: TModel, elfPath: string): void;
    start(options: IStartOptions): Promise<void>;
    connect(): Promise<void>;
    private assignPortsToListen;
    log(message: string): void;
    startGRPCServer(ip: string, port: number): void;
    stopGRPCServer(): void;
    close(): Promise<void>;
    getTransport(): Transport;
    getWindowRect(): IDeviceWindow;
    fetchSnapshot(url: string): Promise<AxiosResponse<Buffer, any>>;
    saveSnapshot(arrayBuffer: Buffer, filePath: string): void;
    convertBufferToPNG(arrayBuffer: Buffer): PNGWithMetadata;
    snapshot(filename?: string): Promise<ISnapshot>;
    getMainMenuSnapshot(): ISnapshot;
    waitUntilScreenIs(screen: ISnapshot, timeout?: number): Promise<void>;
    waitUntilScreenIsNot(screen: ISnapshot, timeout?: number): Promise<void>;
    waitForScreenChanges(prevEvents: IEvent[], timeout?: number): Promise<void>;
    formatIndexString(i: number): string;
    getSnapshotPath(snapshotPrefix: string, index: number, takeSnapshots: boolean): string;
    toggleExpertMode(testcaseName?: string, takeSnapshots?: boolean, startImgIndex?: number): Promise<number>;
    activateShortcutMode(testcaseName?: string, takeSnapshots?: boolean, startImgIndex?: number): Promise<number>;
    navigate(path: string, testcaseName: string, navigateSchedule: Array<INavElement | number>, waitForScreenUpdate?: boolean, takeSnapshots?: boolean, startImgIndex?: number): Promise<number>;
    takeSnapshotAndOverwrite(path: string, testcaseName: string, imageIndex: number): Promise<void>;
    navigateAndCompareSnapshots(path: string, testcaseName: string, navigateSchedule: Array<INavElement | number>, waitForScreenUpdate?: boolean, startImgIndex?: number): Promise<boolean>;
    compareSnapshots(path: string, testcaseName: string, lastSnapshotIdx: number): boolean;
    compareSnapshotsAndApprove(path: string, testcaseName: string, waitForScreenUpdate?: boolean, startImgIndex?: number, timeout?: number): Promise<boolean>;
    compareSnapshotsAndReject(path: string, testcaseName: string, waitForScreenUpdate?: boolean, startImgIndex?: number, timeout?: number): Promise<boolean>;
    navigateUntilText(path: string, testcaseName: string, text: string, waitForScreenUpdate?: boolean, takeSnapshots?: boolean, startImgIndex?: number, timeout?: number, runLastAction?: boolean): Promise<number>;
    navigateAndCompareUntilText(path: string, testcaseName: string, text: string, waitForScreenUpdate?: boolean, startImgIndex?: number, timeout?: number): Promise<boolean>;
    getEvents(): Promise<IEvent[]>;
    deleteEvents(): Promise<void>;
    dumpEvents(): Promise<void>;
    waitForText(text: string | RegExp, timeout?: number, caseSensitive?: boolean): Promise<void>;
    click(endpoint: string, filename?: string, waitForScreenUpdate?: boolean): Promise<ISnapshot>;
    clickLeft(filename?: string, waitForScreenUpdate?: boolean): Promise<ISnapshot>;
    clickRight(filename?: string, waitForScreenUpdate?: boolean): Promise<ISnapshot>;
    clickBoth(filename?: string, waitForScreenUpdate?: boolean): Promise<ISnapshot>;
    fingerTouch(button: IButton, filename?: string, waitForScreenUpdate?: boolean): Promise<ISnapshot>;
    runAction(navElement: INavElement, filename?: string, waitForScreenUpdate?: boolean): Promise<void>;
    runActionBatch(navElements: INavElement[], filename?: string, waitForScreenUpdate?: boolean): Promise<void>;
}
