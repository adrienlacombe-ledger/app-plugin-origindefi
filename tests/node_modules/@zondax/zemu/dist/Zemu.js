"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/** ******************************************************************************
 *  (c) 2018 - 2023 Zondax AG
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ******************************************************************************* */
const axios_1 = __importDefault(require("axios"));
const axios_retry_1 = __importDefault(require("axios-retry"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const get_port_1 = __importDefault(require("get-port"));
const pngjs_1 = require("pngjs");
const hw_transport_http_1 = __importDefault(require("@ledgerhq/hw-transport-http"));
// @ts-expect-error typings are missing
const elfy_1 = __importDefault(require("elfy"));
const path_1 = require("path");
const randomstring_1 = __importDefault(require("randomstring"));
const constants_1 = require("./constants");
const emulator_1 = __importDefault(require("./emulator"));
const grpc_1 = __importDefault(require("./grpc"));
const actions_1 = require("./actions");
const buttons_1 = require("./buttons");
const zondax_1 = require("./zondax");
class Zemu {
    constructor(elfPath, libElfs = {}, host = constants_1.DEFAULT_HOST, desiredTransportPort, desiredSpeculosApiPort, emuImage = constants_1.DEFAULT_EMU_IMG) {
        this.transportProtocol = "http";
        this.host = host;
        this.desiredTransportPort = desiredTransportPort;
        this.desiredSpeculosApiPort = desiredSpeculosApiPort;
        this.elfPath = elfPath;
        this.libElfs = libElfs;
        if (this.elfPath == null) {
            throw new Error("elfPath cannot be null!");
        }
        if (!fs_extra_1.default.existsSync(this.elfPath)) {
            throw new Error("elf file was not found! Did you compile?");
        }
        Object.keys(libElfs).forEach((libName) => {
            if (!fs_extra_1.default.existsSync(libElfs[libName])) {
                throw new Error("lib elf file was not found! Did you compile?");
            }
        });
        this.containerName = constants_1.BASE_NAME + randomstring_1.default.generate(12); // generate 12 chars long string
        this.emuContainer = new emulator_1.default(this.elfPath, this.libElfs, emuImage, this.containerName);
    }
    static LoadPng2RGB(filename) {
        const tmpBuffer = fs_extra_1.default.readFileSync(filename);
        return pngjs_1.PNG.sync.read(tmpBuffer);
    }
    static async sleep(timeInMs = constants_1.DEFAULT_KEY_DELAY) {
        await new Promise((resolve) => setTimeout(resolve, timeInMs));
    }
    static stopAllEmuContainers() {
        const timer = setTimeout(function () {
            console.log("Could not kill all containers before timeout!");
            process.exit(1);
        }, constants_1.KILL_TIMEOUT);
        emulator_1.default.killContainerByName(constants_1.BASE_NAME);
        clearTimeout(timer);
    }
    static checkAndPullImage() {
        emulator_1.default.checkAndPullImage(constants_1.DEFAULT_EMU_IMG);
    }
    static checkElf(model, elfPath) {
        const elfsModel = {
            nanos: 0xc0d00001,
            nanox: 0xc0de0001,
            nanosp: 0xc0de0001,
            stax: 0xc0de0001,
        };
        const elfApp = fs_extra_1.default.readFileSync(elfPath);
        const elfInfo = elfy_1.default.parse(elfApp);
        if (elfInfo.entry !== elfsModel[model]) {
            throw new Error(`Are you sure is a ${model} app elf?`);
        }
    }
    async start(options) {
        this.startOptions = options;
        const approveWord = options.approveKeyword;
        const rejectWord = options.approveKeyword;
        if (options.model === "stax") {
            this.startOptions.approveKeyword = approveWord.length === 0 ? constants_1.DEFAULT_STAX_APPROVE_KEYWORD : approveWord;
            this.startOptions.rejectKeyword = rejectWord.length === 0 ? constants_1.DEFAULT_STAX_REJECT_KEYWORD : rejectWord;
        }
        else {
            this.startOptions.approveKeyword = approveWord.length === 0 ? constants_1.DEFAULT_NANO_APPROVE_KEYWORD : approveWord;
            this.startOptions.rejectKeyword = rejectWord.length === 0 ? constants_1.DEFAULT_NANO_REJECT_KEYWORD : rejectWord;
        }
        this.log(`Checking ELF`);
        Zemu.checkElf(this.startOptions.model, this.elfPath);
        try {
            await this.assignPortsToListen();
            if (this.transportPort === undefined || this.speculosApiPort === undefined) {
                const e = new Error("The Speculos API port or/and transport port couldn't be reserved");
                this.log(`[ZEMU] ${e}`);
                throw e;
            }
            this.log(`Starting Container`);
            await this.emuContainer.runContainer({
                ...this.startOptions,
                transportPort: this.transportPort.toString(),
                speculosApiPort: this.speculosApiPort.toString(),
            });
            this.log(`Connecting to container`);
            await this.connect().catch(async (error) => {
                this.log(`${error}`);
                await this.close();
                throw error;
            });
            // Captures main screen
            this.log(`Wait for start text`);
            await this.waitForText(this.startOptions.startText, this.startOptions.startTimeout, this.startOptions.caseSensitive);
            this.log(`Get initial snapshot`);
            this.mainMenuSnapshot = await this.snapshot();
        }
        catch (e) {
            this.log(`[ZEMU] ${e}`);
            throw e;
        }
    }
    async connect() {
        const transportUrl = `${this.transportProtocol}://${this.host}:${this.transportPort}`;
        const start = new Date();
        let connected = false;
        const maxWait = this.startOptions.startDelay;
        while (!connected) {
            const currentTime = new Date();
            const elapsed = currentTime.getTime() - start.getTime();
            if (elapsed > maxWait) {
                throw new Error("Timeout waiting to connect");
            }
            try {
                this.transport = await (0, hw_transport_http_1.default)(transportUrl).open(transportUrl);
                connected = true;
            }
            catch (e) {
                this.log(`WAIT ${this.containerName} ${elapsed} - ${e} ${transportUrl}`);
                connected = false;
            }
            await Zemu.sleep();
        }
    }
    async assignPortsToListen() {
        if (this.transportPort === undefined || this.speculosApiPort === undefined) {
            this.transportPort = await (0, get_port_1.default)({ port: this.desiredTransportPort });
            this.speculosApiPort = await (0, get_port_1.default)({ port: this.desiredSpeculosApiPort });
        }
    }
    log(message) {
        if (this.startOptions.logging) {
            const currentTimestamp = new Date().toISOString().slice(11, 23);
            process.stdout.write(`[ZEMU] ${currentTimestamp}: ${message}\n`);
        }
    }
    startGRPCServer(ip, port) {
        this.grpcManager = new grpc_1.default(ip, port, this.transport);
        this.grpcManager.startServer();
    }
    stopGRPCServer() {
        if (this.grpcManager != null) {
            this.grpcManager.stopServer();
        }
    }
    async close() {
        this.log("Close");
        await this.emuContainer.stop();
        this.stopGRPCServer();
    }
    getTransport() {
        if (this.transport == null)
            throw new Error("Transport is not loaded.");
        return this.transport;
    }
    getWindowRect() {
        switch (this.startOptions.model) {
            case "nanos":
                return constants_1.WINDOW_S;
            case "nanox":
            case "nanosp":
                return constants_1.WINDOW_X;
            case "stax":
                return constants_1.WINDOW_STAX;
            default:
                throw new Error(`model ${this.startOptions.model} not recognized`);
        }
    }
    async fetchSnapshot(url) {
        // Exponential back-off retry delay between requests
        (0, axios_retry_1.default)(axios_1.default, { retryDelay: axios_retry_1.default.exponentialDelay });
        return await (0, axios_1.default)({
            method: "GET",
            url,
            responseType: "arraybuffer",
        });
    }
    saveSnapshot(arrayBuffer, filePath) {
        fs_extra_1.default.writeFileSync(filePath, Buffer.from(arrayBuffer), "binary");
    }
    convertBufferToPNG(arrayBuffer) {
        return pngjs_1.PNG.sync.read(Buffer.from(arrayBuffer));
    }
    async snapshot(filename = "") {
        const snapshotUrl = `${this.transportProtocol}://${this.host}:${this.speculosApiPort}/screenshot`;
        const { data } = await this.fetchSnapshot(snapshotUrl);
        const modelWindow = this.getWindowRect();
        if (filename !== "")
            this.saveSnapshot(data, filename);
        const rect = {
            height: modelWindow.height,
            width: modelWindow.width,
            data,
        };
        return rect;
    }
    getMainMenuSnapshot() {
        return this.mainMenuSnapshot;
    }
    async waitUntilScreenIs(screen, timeout = constants_1.DEFAULT_METHOD_TIMEOUT) {
        const start = new Date();
        const inputSnapshotBufferHex = screen.data;
        let currentSnapshotBufferHex = (await this.snapshot("")).data;
        this.log(`Wait for screen change`);
        while (!inputSnapshotBufferHex.equals(currentSnapshotBufferHex)) {
            const currentTime = new Date();
            const elapsed = currentTime.getTime() - start.getTime();
            if (elapsed > timeout) {
                throw new Error(`Timeout waiting for screen to change (${timeout} ms)`);
            }
            await Zemu.sleep();
            this.log(`Check [${elapsed}ms]`);
            currentSnapshotBufferHex = (await this.snapshot()).data;
        }
        this.log(`Screen matches`);
    }
    async waitUntilScreenIsNot(screen, timeout = constants_1.DEFAULT_METHOD_TIMEOUT) {
        const start = new Date();
        const inputSnapshotBufferHex = screen.data;
        let currentSnapshotBufferHex = (await this.snapshot("")).data;
        this.log(`Wait for screen change`);
        while (inputSnapshotBufferHex.equals(currentSnapshotBufferHex)) {
            const currentTime = new Date();
            const elapsed = currentTime.getTime() - start.getTime();
            if (elapsed > timeout) {
                throw new Error(`Timeout waiting for screen to change (${timeout} ms)`);
            }
            await Zemu.sleep();
            this.log(`Check [${elapsed}ms]`);
            currentSnapshotBufferHex = (await this.snapshot()).data;
        }
        this.log(`Screen changed`);
    }
    async waitForScreenChanges(prevEvents, timeout = constants_1.DEFAULT_METHOD_TIMEOUT) {
        let currEvents = await this.getEvents();
        const startTime = new Date();
        while (currEvents.length === prevEvents.length) {
            await Zemu.sleep();
            currEvents = await this.getEvents();
            const elapsed = new Date().getTime() - startTime.getTime();
            if (elapsed > timeout) {
                throw new Error(`Timeout waiting for screen to change (${timeout} ms)`);
            }
            this.log(`Check [${elapsed}ms]`);
        }
    }
    formatIndexString(i) {
        return `${i}`.padStart(5, "0");
    }
    getSnapshotPath(snapshotPrefix, index, takeSnapshots) {
        return takeSnapshots ? `${snapshotPrefix}/${this.formatIndexString(index)}.png` : "";
    }
    async toggleExpertMode(testcaseName = "", takeSnapshots = false, startImgIndex = 0) {
        const nav = (0, zondax_1.zondaxToggleExpertMode)(this.startOptions.model);
        return await this.navigate(".", testcaseName, nav.schedule, true, takeSnapshots, startImgIndex);
    }
    async activateShortcutMode(testcaseName = "", takeSnapshots = false, startImgIndex = 0) {
        if (this.startOptions.model !== "stax") {
            const expertImgIndex = await this.toggleExpertMode(testcaseName, takeSnapshots, startImgIndex);
            const tmpImgIndex = await this.navigateUntilText(".", testcaseName, "Shortcut", true, takeSnapshots, expertImgIndex);
            return await this.navigateUntilText(".", testcaseName, this.startOptions.approveKeyword, true, takeSnapshots, tmpImgIndex);
        }
        else {
            const nav = (0, zondax_1.zondaxStaxActivateShortcutMode)();
            return await this.navigate(".", testcaseName, nav.schedule, true, takeSnapshots, startImgIndex);
        }
    }
    async navigate(path, testcaseName, navigateSchedule, waitForScreenUpdate = true, takeSnapshots = true, startImgIndex = 0) {
        const snapshotPrefixGolden = (0, path_1.resolve)(`${path}/snapshots/${testcaseName}`);
        const snapshotPrefixTmp = (0, path_1.resolve)(`${path}/snapshots-tmp/${testcaseName}`);
        const navSchedule = (0, actions_1.scheduleToNavElement)(navigateSchedule);
        if (takeSnapshots) {
            fs_extra_1.default.ensureDirSync(snapshotPrefixGolden);
            fs_extra_1.default.ensureDirSync(snapshotPrefixTmp);
        }
        let imageIndex = startImgIndex;
        let filename = this.getSnapshotPath(snapshotPrefixTmp, imageIndex, takeSnapshots);
        this.log(`---------------------------`);
        this.log(`Start        ${filename}`);
        await this.snapshot(filename);
        this.log(`Instructions ${navSchedule}`);
        for (const nav of navSchedule) {
            imageIndex += 1;
            filename = this.getSnapshotPath(snapshotPrefixTmp, imageIndex, takeSnapshots);
            await this.runAction(nav, filename, waitForScreenUpdate);
        }
        await this.dumpEvents();
        return imageIndex;
    }
    async takeSnapshotAndOverwrite(path, testcaseName, imageIndex) {
        const snapshotPrefixTmp = (0, path_1.resolve)(`${path}/snapshots-tmp/${testcaseName}`);
        fs_extra_1.default.ensureDirSync(snapshotPrefixTmp);
        const filename = this.getSnapshotPath(snapshotPrefixTmp, imageIndex, true);
        try {
            if (filename === "")
                throw new Error("Snapshot filename not defined");
            fs_extra_1.default.unlinkSync(filename);
        }
        catch (err) {
            console.log(err);
            throw new Error("Snapshot does not exist");
        }
        await this.snapshot(filename);
    }
    async navigateAndCompareSnapshots(path, testcaseName, navigateSchedule, waitForScreenUpdate = true, startImgIndex = 0) {
        const takeSnapshots = true;
        const lastImgIndex = await this.navigate(path, testcaseName, navigateSchedule, waitForScreenUpdate, takeSnapshots, startImgIndex);
        return this.compareSnapshots(path, testcaseName, lastImgIndex);
    }
    compareSnapshots(path, testcaseName, lastSnapshotIdx) {
        const snapshotPrefixGolden = (0, path_1.resolve)(`${path}/snapshots/${testcaseName}`);
        const snapshotPrefixTmp = (0, path_1.resolve)(`${path}/snapshots-tmp/${testcaseName}`);
        this.log(`golden      ${snapshotPrefixGolden}`);
        this.log(`tmp         ${snapshotPrefixTmp}`);
        this.log(`Start comparison`);
        for (let j = 0; j <= lastSnapshotIdx; j += 1) {
            this.log(`Checked     ${snapshotPrefixTmp}/${this.formatIndexString(j)}.png`);
            const img1 = Zemu.LoadPng2RGB(`${snapshotPrefixTmp}/${this.formatIndexString(j)}.png`);
            const img2 = Zemu.LoadPng2RGB(`${snapshotPrefixGolden}/${this.formatIndexString(j)}.png`);
            if (!img1.data.equals(img2.data)) {
                throw new Error(`Image [${this.formatIndexString(j)}] do not match!`);
            }
        }
        return true;
    }
    async compareSnapshotsAndApprove(path, testcaseName, waitForScreenUpdate = true, startImgIndex = 0, timeout = constants_1.DEFAULT_METHOD_TIMEOUT) {
        const approveKeyword = this.startOptions.approveKeyword;
        const takeSnapshots = true;
        const lastSnapshotIdx = await this.navigateUntilText(path, testcaseName, approveKeyword, waitForScreenUpdate, takeSnapshots, startImgIndex, timeout);
        if (this.startOptions.model === "stax") {
            // Avoid taking a snapshot of the final animation
            await this.waitUntilScreenIs(this.mainMenuSnapshot);
            await this.takeSnapshotAndOverwrite(path, testcaseName, lastSnapshotIdx);
        }
        return this.compareSnapshots(path, testcaseName, lastSnapshotIdx);
    }
    async compareSnapshotsAndReject(path, testcaseName, waitForScreenUpdate = true, startImgIndex = 0, timeout = constants_1.DEFAULT_METHOD_TIMEOUT) {
        const rejectKeyword = this.startOptions.rejectKeyword;
        if (this.startOptions.model !== "stax") {
            return await this.navigateAndCompareUntilText(path, testcaseName, rejectKeyword, waitForScreenUpdate, startImgIndex, timeout);
        }
        else {
            const takeSnapshots = true;
            const runLastAction = false;
            // For Stax devices navigate until reject keyword --> Reject --> Confirm rejection
            // reject keyword should be actually approve keyword (issue with OCR)
            const navLastIndex = await this.navigateUntilText(path, testcaseName, rejectKeyword, waitForScreenUpdate, takeSnapshots, startImgIndex, timeout, runLastAction);
            const rejectConfirmationNav = new actions_1.TouchNavigation([11 /* ButtonKind.RejectButton */, 12 /* ButtonKind.ConfirmYesButton */]);
            // Overwrite last snapshot since navigate starts taking a snapshot of the current screen
            const lastIndex = await this.navigate(path, testcaseName, rejectConfirmationNav.schedule, waitForScreenUpdate, takeSnapshots, navLastIndex - 1);
            return this.compareSnapshots(path, testcaseName, lastIndex);
        }
    }
    async navigateUntilText(path, testcaseName, text, waitForScreenUpdate = true, takeSnapshots = true, startImgIndex = 0, timeout = constants_1.DEFAULT_METHOD_TIMEOUT, runLastAction = true) {
        const snapshotPrefixGolden = (0, path_1.resolve)(`${path}/snapshots/${testcaseName}`);
        const snapshotPrefixTmp = (0, path_1.resolve)(`${path}/snapshots-tmp/${testcaseName}`);
        if (takeSnapshots) {
            fs_extra_1.default.ensureDirSync(snapshotPrefixGolden);
            fs_extra_1.default.ensureDirSync(snapshotPrefixTmp);
        }
        let imageIndex = startImgIndex;
        let filename = this.getSnapshotPath(snapshotPrefixTmp, imageIndex, takeSnapshots);
        await this.snapshot(filename);
        let start = new Date();
        let found = false;
        const isStaxDevice = this.startOptions.model === "stax";
        while (!found) {
            const currentTime = new Date();
            const elapsed = currentTime.getTime() - start.getTime();
            if (elapsed > timeout) {
                throw new Error(`Timeout waiting for screen containing ${text}`);
            }
            const events = await this.getEvents();
            imageIndex += 1;
            filename = this.getSnapshotPath(snapshotPrefixTmp, imageIndex, takeSnapshots);
            found = events.some((event) => event.text.includes(text));
            if (found)
                break;
            const nav = {
                type: isStaxDevice ? 3 /* ActionKind.Touch */ : 1 /* ActionKind.RightClick */,
                button: buttons_1.tapContinueButton, // For clicks, this will be ignored
            };
            await this.runAction(nav, filename, waitForScreenUpdate);
            start = new Date();
        }
        if (!runLastAction)
            return imageIndex; // do not run last action if requested
        // Approve can be performed with Tap or PressAndHold
        const staxApproveButton = buttons_1.TouchElements.get(this.startOptions.approveAction);
        const nav = {
            type: isStaxDevice ? 3 /* ActionKind.Touch */ : 2 /* ActionKind.BothClick */,
            button: staxApproveButton ?? buttons_1.dummyButton,
        };
        await this.runAction(nav, filename, waitForScreenUpdate);
        return imageIndex;
    }
    async navigateAndCompareUntilText(path, testcaseName, text, waitForScreenUpdate = true, startImgIndex = 0, timeout = constants_1.DEFAULT_METHOD_TIMEOUT) {
        const takeSnapshots = true;
        const lastImgIndex = await this.navigateUntilText(path, testcaseName, text, waitForScreenUpdate, takeSnapshots, startImgIndex, timeout);
        return this.compareSnapshots(path, testcaseName, lastImgIndex);
    }
    async getEvents() {
        (0, axios_retry_1.default)(axios_1.default, { retryDelay: axios_retry_1.default.exponentialDelay });
        const eventsUrl = `${this.transportProtocol}://${this.host}:${this.speculosApiPort}/events`;
        try {
            const { data } = await axios_1.default.get(eventsUrl);
            return data.events;
        }
        catch (error) {
            return [];
        }
    }
    async deleteEvents() {
        await (0, axios_1.default)({
            method: "DELETE",
            url: `${this.transportProtocol}://${this.host}:${this.speculosApiPort}/events`,
        });
    }
    async dumpEvents() {
        const events = await this.getEvents();
        if (events != null) {
            events.forEach((x) => {
                this.log(`[ZEMU] ${JSON.stringify(x)}`);
            });
        }
    }
    async waitForText(text, timeout = constants_1.DEFAULT_METHOD_TIMEOUT, caseSensitive = false) {
        const start = new Date();
        let found = false;
        const flags = !caseSensitive ? "i" : "";
        const startRegex = new RegExp(text, flags);
        while (!found) {
            const currentTime = new Date();
            const elapsed = currentTime.getTime() - start.getTime();
            if (elapsed > timeout) {
                throw new Error(`Timeout (${timeout}) waiting for text (${text})`);
            }
            const events = await this.getEvents();
            found = events.some((event) => {
                this.log(JSON.stringify(event));
                return startRegex.test(event.text);
            });
            await Zemu.sleep();
        }
    }
    async click(endpoint, filename = "", waitForScreenUpdate = true) {
        const prevEvents = await this.getEvents();
        const clickUrl = `${this.transportProtocol}://${this.host}:${this.speculosApiPort}${endpoint}`;
        const payload = { action: "press-and-release" };
        await axios_1.default.post(clickUrl, payload);
        this.log(`Click ${endpoint} -> ${filename}`);
        // Wait and poll Speculos until the application screen gets updated
        if (waitForScreenUpdate)
            await this.waitForScreenChanges(prevEvents);
        else
            await Zemu.sleep(); // A minimum delay is required
        return await this.snapshot(filename);
    }
    async clickLeft(filename = "", waitForScreenUpdate = true) {
        return await this.click("/button/left", filename, waitForScreenUpdate);
    }
    async clickRight(filename = "", waitForScreenUpdate = true) {
        return await this.click("/button/right", filename, waitForScreenUpdate);
    }
    async clickBoth(filename = "", waitForScreenUpdate = true) {
        return await this.click("/button/both", filename, waitForScreenUpdate);
    }
    async fingerTouch(button, filename = "", waitForScreenUpdate = true) {
        const prevEvents = await this.getEvents();
        const prevScreen = await this.snapshot();
        const fingerTouchUrl = `${this.transportProtocol}://${this.host}:${this.speculosApiPort}/finger`;
        const payload = { action: "press-and-release", x: button.x, y: button.y, delay: button.delay };
        await axios_1.default.post(fingerTouchUrl, payload);
        this.log(`Touch /finger -> ${filename}`);
        // Wait and poll Speculos until the application screen gets updated
        if (waitForScreenUpdate) {
            await this.waitForScreenChanges(prevEvents);
            await this.waitUntilScreenIsNot(prevScreen);
        }
        else {
            // A minimum delay is required
            await Zemu.sleep();
        }
        return await this.snapshot(filename);
    }
    async runAction(navElement, filename = "", waitForScreenUpdate = true) {
        switch (navElement.type) {
            case 1 /* ActionKind.RightClick */:
                await this.clickRight(filename, waitForScreenUpdate);
                break;
            case 0 /* ActionKind.LeftClick */:
                await this.clickLeft(filename, waitForScreenUpdate);
                break;
            case 2 /* ActionKind.BothClick */:
                await this.clickBoth(filename, waitForScreenUpdate);
                break;
            case 3 /* ActionKind.Touch */:
                await this.fingerTouch(navElement.button, filename, waitForScreenUpdate);
                break;
            default:
                throw new Error("Action type not implemented");
        }
    }
    async runActionBatch(navElements, filename = "", waitForScreenUpdate = true) {
        for (const nav of navElements) {
            await this.runAction(nav, filename, waitForScreenUpdate);
        }
    }
}
exports.default = Zemu;
